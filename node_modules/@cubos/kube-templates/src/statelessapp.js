"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatelessApp = void 0;
var url_1 = require("url");
var helpers_1 = require("./helpers");
var kubernetes_1 = require("./kubernetes");
var StatelessApp = /** @class */ (function () {
    function StatelessApp(metadata, spec) {
        this.metadata = metadata;
        this.spec = spec;
    }
    Object.defineProperty(StatelessApp.prototype, "yaml", {
        get: function () {
            var _a, _b;
            var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
            var ingress = new kubernetes_1.Ingress(helpers_1.clone(this.metadata), { rules: [], tls: [] });
            for (var _i = 0, _x = (_c = this.spec.ports) !== null && _c !== void 0 ? _c : []; _i < _x.length; _i++) {
                var portSpec = _x[_i];
                if (portSpec.type !== "http" ||
                    (!portSpec.publicUrl && !((_d = portSpec.endpoints) === null || _d === void 0 ? void 0 : _d.length)))
                    continue;
                if (portSpec.publicUrl) {
                    if (!portSpec.endpoints) {
                        portSpec.endpoints = [];
                    }
                    var publicUrls = Array.isArray(portSpec.publicUrl)
                        ? portSpec.publicUrl
                        : [portSpec.publicUrl];
                    for (var _y = 0, publicUrls_1 = publicUrls; _y < publicUrls_1.length; _y++) {
                        var publicUrl = publicUrls_1[_y];
                        portSpec.endpoints.push({
                            maxBodySize: portSpec.maxBodySize,
                            tlsCert: portSpec.tlsCert,
                            publicUrl: publicUrl,
                        });
                    }
                }
                var maxBodySizeBytes = null;
                var hasPath = false;
                var _loop_1 = function (endpointSpec) {
                    if (!endpointSpec.publicUrl)
                        return "continue";
                    var _a = new url_1.URL(endpointSpec.publicUrl), protocol = _a.protocol, hostname = _a.hostname, pathname = _a.pathname;
                    var rule = ingress.spec.rules.find(function (x) { return x.host === hostname; });
                    if (!rule) {
                        ingress.spec.rules.push((rule = { host: hostname, http: { paths: [] } }));
                    }
                    if (protocol === "https:") {
                        if (!endpointSpec.tlsCert) {
                            throw "Uma URL com HTTPS foi utilizada, mas 'tlsCert' nÃ£o foi informado";
                        }
                        var tls = ingress.spec.tls.find(function (x) { return x.secretName === endpointSpec.tlsCert; });
                        if (!tls) {
                            ingress.spec.tls.push((tls = { secretName: endpointSpec.tlsCert, hosts: [] }));
                        }
                        if (!tls.hosts.includes(hostname))
                            tls.hosts.push(hostname);
                    }
                    if (!rule.http) {
                        rule.http = { paths: [] };
                    }
                    hasPath = hasPath || pathname !== "/";
                    rule.http.paths.push({
                        backend: {
                            serviceName: this_1.metadata.name,
                            servicePort: portSpec.port,
                        },
                        path: pathname === "/"
                            ? (portSpec.ingressClass === "alb" ? "/*" : pathname)
                            : (pathname.endsWith("/")
                                ? pathname.substring(0, pathname.length - 1)
                                : pathname) + "(/|$)(.*)",
                    });
                    if (endpointSpec.maxBodySize) {
                        var endpointMaxBodySizeBytes = helpers_1.parseMemory(endpointSpec.maxBodySize);
                        if (!maxBodySizeBytes ||
                            endpointMaxBodySizeBytes > maxBodySizeBytes) {
                            maxBodySizeBytes = endpointMaxBodySizeBytes;
                        }
                    }
                };
                var this_1 = this;
                for (var _z = 0, _0 = (_e = portSpec.endpoints) !== null && _e !== void 0 ? _e : []; _z < _0.length; _z++) {
                    var endpointSpec = _0[_z];
                    _loop_1(endpointSpec);
                }
                ingress.metadata.annotations = __assign(__assign({}, ingress.metadata.annotations), portSpec.ingressAnnotations);
                // TODO: This shouldn't be global on entire Ingress. Should be per port.
                if (maxBodySizeBytes) {
                    ingress.metadata.annotations["nginx.ingress.kubernetes.io/proxy-body-size"] = maxBodySizeBytes.toString();
                }
                if (portSpec.timeout) {
                    ingress.metadata.annotations["nginx.ingress.kubernetes.io/proxy-read-timeout"] = portSpec.timeout.toString();
                }
                if (hasPath) {
                    ingress.metadata.annotations["nginx.ingress.kubernetes.io/rewrite-target"] = "/$2";
                }
                if (process.env.CUBOS_DEV_GKE && !process.env.PRODUCTION) {
                    ingress.metadata.annotations["kubernetes.io/ingress.class"] = (_f = portSpec.ingressClass) !== null && _f !== void 0 ? _f : "private";
                }
            }
            var basicProbe = undefined;
            if (this.spec.check === undefined) {
            }
            else if (this.spec.check.command) {
                basicProbe = {
                    exec: {
                        command: this.spec.check.command,
                    },
                    periodSeconds: (_g = this.spec.check.period) !== null && _g !== void 0 ? _g : 3,
                };
            }
            else if (this.spec.check.httpGetPath) {
                basicProbe = {
                    httpGet: {
                        path: this.spec.check.httpGetPath,
                        port: this.spec.check.port,
                        httpHeaders: this.spec.check.host
                            ? [{ name: "Host", value: this.spec.check.host }]
                            : [],
                    },
                    periodSeconds: (_h = this.spec.check.period) !== null && _h !== void 0 ? _h : 3,
                };
            }
            else {
                basicProbe = {
                    tcpSocket: {
                        port: this.spec.check.port,
                    },
                    periodSeconds: (_j = this.spec.check.period) !== null && _j !== void 0 ? _j : 3,
                };
            }
            var volumes = [];
            var volumeMounts = [];
            for (var _1 = 0, _2 = (_k = this.spec.volumes) !== null && _k !== void 0 ? _k : []; _1 < _2.length; _1++) {
                var volume = _2[_1];
                var name = "vol-" + volume.mountPath.replace(/[^a-zA-Z0-9]/gu, "");
                volumes.push((_a = {
                        name: name
                    },
                    _a[volume.type] = (_b = {},
                        _b[volume.type === "secret" ? "secretName" : "name"] = volume.name,
                        _b.items = volume.items,
                        _b.optional = (_l = volume.optional) !== null && _l !== void 0 ? _l : false,
                        _b),
                    _a));
                volumeMounts.push({
                    name: name,
                    readOnly: (_m = volume.readOnly) !== null && _m !== void 0 ? _m : true,
                    mountPath: volume.mountPath,
                });
            }
            return helpers_1.generateYaml(__spreadArrays([
                new kubernetes_1.Deployment(this.metadata, {
                    replicas: Array.isArray(this.spec.replicas)
                        ? undefined // https://github.com/kubernetes/kubernetes/issues/25238
                        : (_o = this.spec.replicas) !== null && _o !== void 0 ? _o : 1,
                    revisionHistoryLimit: 2,
                    selector: {
                        matchLabels: {
                            app: this.metadata.name,
                        },
                    },
                    template: {
                        metadata: {
                            labels: {
                                app: this.metadata.name,
                            },
                        },
                        spec: __assign(__assign(__assign(__assign({ affinity: {
                                podAntiAffinity: process.env.PRODUCTION_CUBOS
                                    ? {
                                        requiredDuringSchedulingIgnoredDuringExecution: [
                                            {
                                                labelSelector: {
                                                    matchLabels: {
                                                        app: this.metadata.name,
                                                    },
                                                },
                                                topologyKey: "kubernetes.io/hostname",
                                            },
                                        ],
                                    }
                                    : {
                                        preferredDuringSchedulingIgnoredDuringExecution: [
                                            {
                                                weight: 100,
                                                podAffinityTerm: {
                                                    labelSelector: {
                                                        matchLabels: {
                                                            app: this.metadata.name,
                                                        },
                                                    },
                                                    topologyKey: "kubernetes.io/hostname",
                                                },
                                            },
                                        ],
                                    },
                            } }, ((this.spec.image.startsWith("registry.cubos.io") || this.spec.image.startsWith("registry.gitlab.com/mimic1"))
                            ? {
                                imagePullSecrets: [
                                    {
                                        name: "gitlab-registry",
                                    },
                                ],
                            }
                            : this.spec.image.includes("gcr.io/cubos-203208")
                                ? {
                                    imagePullSecrets: [
                                        {
                                            name: "google-cloud-registry",
                                        },
                                    ],
                                }
                                : {})), { automountServiceAccountToken: false }), (process.env.PRODUCTION &&
                            this.spec.replicas !== undefined &&
                            ((Array.isArray(this.spec.replicas) &&
                                this.spec.replicas[0] >= 2) ||
                                this.spec.replicas >= 2) &&
                            !((_p = this.spec.disablePreemptibility) !== null && _p !== void 0 ? _p : false)
                            ? {
                                tolerations: [
                                    {
                                        key: "preemptible",
                                        operator: "Equal",
                                        value: "true",
                                        effect: "NoSchedule",
                                    },
                                ],
                                nodeSelector: {
                                    preemptible: "true",
                                },
                            }
                            : {})), { volumes: volumes, containers: [
                                {
                                    name: this.metadata.name,
                                    image: this.spec.image,
                                    command: this.spec.command,
                                    env: __spreadArrays((this.spec.envs
                                        ? Object.entries(this.spec.envs).map(function (_a) {
                                            var name = _a[0], value = _a[1];
                                            return typeof value === "object"
                                                ? {
                                                    name: name,
                                                    valueFrom: {
                                                        secretKeyRef: {
                                                            name: value.secretName,
                                                            key: value.key,
                                                        },
                                                    },
                                                }
                                                : {
                                                    name: name,
                                                    value: "" + value,
                                                };
                                        })
                                        : []), ((_q = this.spec.forwardEnvs) !== null && _q !== void 0 ? _q : []).map(function (key) { return ({
                                        name: key,
                                        value: helpers_1.env[key],
                                    }); })),
                                    envFrom: (_s = (_r = this.spec.secretEnvs) === null || _r === void 0 ? void 0 : _r.map(function (name) { return ({
                                        secretRef: {
                                            name: name,
                                        },
                                    }); })) !== null && _s !== void 0 ? _s : [],
                                    resources: {
                                        limits: {
                                            cpu: this.spec.cpu.limit,
                                            memory: this.spec.memory.limit,
                                        },
                                        requests: {
                                            cpu: this.spec.cpu.request,
                                            memory: this.spec.memory.request,
                                        },
                                    },
                                    ports: ((_t = this.spec.ports) !== null && _t !== void 0 ? _t : []).map(function (portSpec) {
                                        var _a, _b;
                                        return ({
                                            name: (_a = portSpec.name) !== null && _a !== void 0 ? _a : "port" + portSpec.port,
                                            containerPort: (_b = portSpec.containerPort) !== null && _b !== void 0 ? _b : portSpec.port,
                                        });
                                    }),
                                    volumeMounts: volumeMounts,
                                    readinessProbe: basicProbe
                                        ? __assign(__assign({}, basicProbe), { failureThreshold: 1, successThreshold: 2 }) : undefined,
                                    livenessProbe: basicProbe
                                        ? __assign(__assign({}, basicProbe), { failureThreshold: 5, initialDelaySeconds: (_v = (_u = this.spec.check) === null || _u === void 0 ? void 0 : _u.initialDelay) !== null && _v !== void 0 ? _v : 5 }) : undefined,
                                },
                            ] }),
                    },
                })
            ], (((_w = this.spec.ports) !== null && _w !== void 0 ? _w : []).length === 0
                ? []
                : [
                    new kubernetes_1.Service(this.metadata, {
                        type: this.spec.ports[0].serviceType,
                        selector: {
                            app: this.metadata.name,
                        },
                        ports: this.spec.ports.map(function (portSpec) {
                            var _a, _b;
                            return ({
                                name: (_a = portSpec.name) !== null && _a !== void 0 ? _a : "port" + portSpec.port,
                                port: portSpec.port,
                                targetPort: (_b = portSpec.containerPort) !== null && _b !== void 0 ? _b : portSpec.port,
                            });
                        }),
                    }),
                ]), (ingress.spec.rules.length ? [ingress] : []), (this.spec.replicas && Array.isArray(this.spec.replicas)
                ? [
                    new kubernetes_1.HorizontalPodAutoscaler(this.metadata, {
                        maxReplicas: this.spec.replicas[1],
                        minReplicas: this.spec.replicas[0],
                        scaleTargetRef: {
                            apiVersion: "apps/v1",
                            kind: "Deployment",
                            name: this.metadata.name,
                        },
                        targetCPUUtilizationPercentage: 75,
                    }),
                ]
                : [])));
        },
        enumerable: false,
        configurable: true
    });
    return StatelessApp;
}());
exports.StatelessApp = StatelessApp;
