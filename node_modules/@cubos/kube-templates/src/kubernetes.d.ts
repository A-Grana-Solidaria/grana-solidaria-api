/// <reference types="node" />
export interface BasicObjectMeta {
    annotations?: {
        [annotation: string]: string;
    };
    labels?: {
        [label: string]: string;
    };
}
interface NonNamespacedObjectMeta extends BasicObjectMeta {
    name: string;
}
export interface ObjectMeta extends NonNamespacedObjectMeta {
    namespace: string;
}
interface DeploymentSpec {
    minReadySeconds?: number;
    paused?: boolean;
    progressDeadlineSeconds?: number;
    replicas?: number;
    revisionHistoryLimit?: number;
    selector?: LabelSelector;
    strategy?: DeploymentStrategy;
    template: PodTemplateSpec;
}
interface LabelSelector {
    matchExpressions?: LabelSelectorRequirement[];
    matchLabels?: {
        [label: string]: string;
    };
}
interface LabelSelectorRequirement {
    key: string;
    operator: "In" | "NotIn" | "Exists" | "DoesNotExist";
    values: string[];
}
interface DeploymentStrategy {
    maxSurge?: number | string;
    maxUnavailable?: number | string;
}
interface PodTemplateSpec {
    metadata?: BasicObjectMeta;
    spec: PodSpec;
}
interface PodSpec {
    activeDeadlineSeconds?: number;
    affinity?: Affinity;
    automountServiceAccountToken?: boolean;
    containers: Container[];
    dnsPolicy?: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
    enableServiceLinks?: boolean;
    hostIPC?: boolean;
    hostNetwork?: boolean;
    hostPID?: boolean;
    hostname?: string;
    imagePullSecrets?: LocalObjectReference[];
    initContainers?: Container[];
    nodeName?: string;
    nodeSelector?: {
        [annotation: string]: string;
    };
    priority?: number;
    priorityClassName?: string;
    preemptionPolicy?: "Never" | "PreemptLowerPriority";
    restartPolicy?: "Always" | "OnFailure" | "Never";
    runtimeClassName?: string;
    schedulerName?: string;
    securityContext?: PodSecurityContext;
    serviceAccountName?: string;
    shareProcessNamespace?: boolean;
    subdomain?: string;
    terminationGracePeriodSeconds?: number;
    tolerations?: Toleration[];
    volumes?: Volume[];
}
interface PodDisruptionBudgetSpec {
    selector: LabelSelector;
    maxUnavailable: number;
}
interface Toleration {
    effect: string;
    key: string;
    operator?: "Exists" | "Equal";
    tolerationSeconds?: number;
    value?: string;
}
interface KeyToPath {
    key: string;
    path: string;
    mode?: string;
}
export declare type Volume = {
    name: string;
} & (// | {
{
    configMap: {
        defaultMode?: number;
        items?: KeyToPath[];
        name: string;
        optional?: boolean;
    };
} | {
    emptyDir: {
        medium?: "" | "Memory";
        sizeLimit?: number | string;
    };
} | {
    hostPath: {
        path: string;
        type?: "" | "DirectoryOrCreate" | "Directory" | "FileOrCreate" | "File" | "Socket" | "CharDevice" | "BlockDevice";
    };
} | {
    persistentVolumeClaim: {
        claimName: string;
        readonly?: boolean;
    };
} | {
    secret: {
        defaultMode?: number;
        items?: KeyToPath[];
        optional?: boolean;
        secretName: string;
    };
});
interface Affinity {
    nodeAffinity?: NodeAffinity;
    podAffinity?: PodAffinity;
    podAntiAffinity?: PodAntiAffinity;
}
interface NodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
    requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
}
interface PodAffinity {
    preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
    requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
}
interface PodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecution?: WeightedPodAffinityTerm[];
    requiredDuringSchedulingIgnoredDuringExecution?: PodAffinityTerm[];
}
interface NodeSelector {
    nodeSelectorTerms?: NodeSelectorTerm[];
}
interface PreferredSchedulingTerm {
    preference?: NodeSelectorTerm;
    weight: number;
}
interface WeightedPodAffinityTerm {
    podAffinityTerm?: PodAffinityTerm;
    weight: number;
}
interface PodAffinityTerm {
    labelSelector?: LabelSelector;
    namespaces?: string[];
    topologyKey: string;
}
interface NodeSelectorTerm {
    matchExpressions?: NodeSelectorRequirement[];
    matchFields?: NodeSelectorRequirement[];
}
interface NodeSelectorRequirement {
    key: string;
    operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
    values: string[];
}
interface SecretEnvSource {
    name: string;
    optional?: boolean;
}
interface ConfigMapEnvSource {
    name: string;
    optional?: boolean;
}
interface EnvFromSource {
    configMapRef?: ConfigMapEnvSource;
    prefix?: string;
    secretRef?: SecretEnvSource;
}
interface SELinuxOptions {
    user?: string;
    role?: string;
    type?: string;
    level?: string;
}
interface WindowsSecurityContextOptions {
    gmsaCredentialSpec?: string;
    gmsaCredentialSpecName?: string;
    runAsUserName?: string;
}
interface SecurityContext {
    allowPrivilegeEscalation?: boolean;
    capabilities?: {
        add?: string[];
        drop?: string[];
    };
    privileged?: boolean;
    procMount?: "Default" | "Unmasked";
    readOnlyRootFilesystem?: boolean;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    runAsUser?: number;
    seLinuxOptions?: SELinuxOptions;
    windowsOptions?: WindowsSecurityContextOptions;
}
interface PodSecurityContext {
    fsGroup?: number;
    runAsGroup?: number;
    runAsNonRoot?: boolean;
    runAsUser?: number;
    seLinuxOptions?: SELinuxOptions;
    supplementalGroups?: number[];
    sysctls?: Array<{
        name: string;
        value: string;
    }>;
    windowsOptions?: WindowsSecurityContextOptions;
}
export interface Container {
    args?: string[];
    command?: string[];
    env?: EnvVar[];
    envFrom?: EnvFromSource[];
    image: string;
    imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
    livenessProbe?: Probe;
    name: string;
    ports?: ContainerPort[];
    readinessProbe?: Probe;
    resources?: {
        limits?: {
            memory?: string | number;
            cpu?: string | number;
        };
        requests?: {
            memory?: string | number;
            cpu?: string | number;
        };
    };
    securityContext?: SecurityContext;
    startupProbe?: Probe;
    stdin?: boolean;
    stdinOnce?: boolean;
    terminationMessagePath?: string;
    terminationMessagePolicy?: string;
    tty?: boolean;
    volumeMounts?: VolumeMount[];
    workingDir?: string;
}
export interface VolumeMount {
    mountPath: string;
    mountPropagation?: string;
    name: string;
    readOnly?: boolean;
    subPath?: string;
}
declare type Probe = ({
    exec: ExecAction;
} | {
    tcpSocket: TCPSocketAction;
} | {
    httpGet: HTTPGetAction;
}) & {
    failureThreshold?: number;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    timeoutSeconds?: number;
};
interface ExecAction {
    command: string[];
}
interface TCPSocketAction {
    host?: string;
    port: number;
}
interface HTTPGetAction {
    host?: string;
    httpHeaders?: HTTPHeader[];
    path: string;
    port?: number;
    scheme?: "HTTP" | "HTTPS";
}
interface HTTPHeader {
    name: string;
    value: string;
}
interface ContainerPort {
    containerPort: number;
    hostIP?: string;
    hostPort?: number;
    name?: string;
    protocol?: "TCP" | "UDP" | "SCTP";
}
declare type EnvVar = EnvVarWithValue | EnvVarWithFrom;
interface EnvVarWithValue {
    name: string;
    value: string;
}
interface EnvVarWithFrom {
    name: string;
    valueFrom: EnvVarSource;
}
declare type EnvVarSource = {
    configMapKeyRef: ConfigMapKeySelector;
} | {
    fieldRef: ObjectFieldSelector;
} | {
    resourceFieldRef: ResourceFieldSelector;
} | {
    secretKeyRef: SecretKeySelector;
};
interface ConfigMapKeySelector {
    key: string;
    name: string;
    optional?: boolean;
}
interface SecretKeySelector {
    key: string;
    name: string;
    optional?: boolean;
}
interface ObjectFieldSelector {
    apiVersion?: string;
    fieldPath: string;
}
interface ResourceFieldSelector {
    containerName?: string;
    divisor?: number | string;
    resource: string;
}
interface LocalObjectReference {
    name: string;
}
interface ServiceSpec {
    clusterIP?: string;
    externalIPs?: string[];
    externalName?: string;
    externalTrafficPolicy?: "Local" | "Cluster";
    healthCheckNodePort?: number;
    ipFamily?: string;
    loadBalancerIP?: string;
    loadBalancerSourceRanges?: string[];
    ports?: ServicePort[];
    publishNotReadyAddresses?: boolean;
    selector?: {
        [label: string]: string;
    };
    sessionAffinity?: "ClientIP" | "None";
    sessionAffinityConfig?: SessionAffinityConfig;
    topologyKeys?: string[];
    type?: "ExternalName" | "ClusterIP" | "NodePort" | "LoadBalancer";
}
interface SessionAffinityConfig {
    clientIP: ClientIPConfig;
}
interface ClientIPConfig {
    timeoutSeconds: number;
}
interface ServicePort {
    name: string;
    nodePort?: number;
    port: number;
    protocol?: "TCP" | "UDP" | "SCTP";
    targetPort?: number;
}
interface IngressSpec {
    backend?: IngressBackend;
    rules?: IngressRule[];
    tls?: IngressTLS[];
}
interface IngressBackend {
    serviceName: string;
    servicePort: number;
}
interface IngressRule {
    host: string;
    http?: HTTPIngressRuleValue;
}
interface IngressTLS {
    hosts?: string[];
    secretName: string;
}
interface HTTPIngressRuleValue {
    paths: HTTPIngressPath[];
}
interface HTTPIngressPath {
    backend: IngressBackend;
    path: string;
}
interface HorizontalPodAutoscalerSpec {
    maxReplicas: number;
    minReplicas: number;
    scaleTargetRef: CrossVersionObjectReference;
    targetCPUUtilizationPercentage: number;
}
interface CrossVersionObjectReference {
    apiVersion: string;
    kind: string;
    name: string;
}
interface StatefulSetSpec {
    podManagementPolicy?: "OrderedReady" | "Parallel";
    replicas?: number;
    revisionHistoryLimit?: number;
    selector: LabelSelector;
    serviceName: string;
    template: PodTemplateSpec;
    updateStrategy?: StatefulSetUpdateStrategy;
    volumeClaimTemplates: {
        metadata: NonNamespacedObjectMeta;
        spec: PersistentVolumeClaimSpec;
    }[];
}
interface StatefulSetUpdateStrategy {
    rollingUpdate?: RollingUpdateStatefulSetStrategy;
    type: "RollingUpdate";
}
interface RollingUpdateStatefulSetStrategy {
    partition: number;
}
interface PersistentVolumeClaimSpec {
    accessModes: ("ReadWriteOnce" | "ReadOnlyMany" | "ReadWriteMany")[];
    dataSource?: TypedLocalObjectReference;
    resources: {
        requests: {
            storage: string | number;
        };
    };
    selector?: LabelSelector;
    storageClassName?: string;
    volumeMode?: "Filesystem" | "Block";
    volumeName?: string;
}
interface TypedLocalObjectReference {
    apiGroup: string;
    kind: string;
    name: string;
}
interface JobSpec {
    activeDeadlineSeconds?: number;
    backoffLimit?: number;
    completions?: number;
    manualSelector?: boolean;
    parallelism?: number;
    selector: LabelSelector;
    template: PodTemplateSpec;
    ttlSecondsAfterFinished?: number;
}
interface JobTemplateSpec {
    metadata?: ObjectMeta;
    spec: Omit<JobSpec, "selector">;
}
interface CronJobSpec {
    concurrencyPolicy?: "Allow" | "Forbid" | "Replace";
    failedJobsHistoryLimit?: number;
    jobTemplate: JobTemplateSpec;
    schedule: string;
    startingDeadlineSeconds?: number;
    successfulJobsHistoryLimit?: number;
    suspend?: boolean;
}
interface NamespaceSpec {
    finalizers?: string[];
}
export declare class Namespace {
    metadata: NonNamespacedObjectMeta;
    spec?: NamespaceSpec | undefined;
    constructor(metadata: NonNamespacedObjectMeta, spec?: NamespaceSpec | undefined);
    get yaml(): string;
}
export declare class Deployment {
    metadata: ObjectMeta;
    spec: DeploymentSpec;
    constructor(metadata: ObjectMeta, spec: DeploymentSpec);
    get yaml(): string;
}
export declare class StatefulSet {
    metadata: ObjectMeta;
    spec: StatefulSetSpec;
    constructor(metadata: ObjectMeta, spec: StatefulSetSpec);
    get yaml(): string;
}
export declare class Service {
    metadata: ObjectMeta;
    spec: ServiceSpec;
    constructor(metadata: ObjectMeta, spec: ServiceSpec);
    get yaml(): string;
}
export declare class Ingress {
    metadata: ObjectMeta;
    spec: IngressSpec;
    constructor(metadata: ObjectMeta, spec: IngressSpec);
    get yaml(): string;
}
export declare class HorizontalPodAutoscaler {
    metadata: ObjectMeta;
    spec: HorizontalPodAutoscalerSpec;
    constructor(metadata: ObjectMeta, spec: HorizontalPodAutoscalerSpec);
    get yaml(): string;
}
export declare class Secret {
    metadata: ObjectMeta;
    data?: {
        [key: string]: string | Buffer;
    } | undefined;
    constructor(metadata: ObjectMeta, data?: {
        [key: string]: string | Buffer;
    } | undefined);
    get yaml(): string;
}
export declare class ConfigMap {
    metadata: ObjectMeta;
    data?: {
        [key: string]: string;
    } | undefined;
    constructor(metadata: ObjectMeta, data?: {
        [key: string]: string;
    } | undefined);
    get yaml(): string;
}
export declare class CronJob {
    metadata: ObjectMeta;
    spec: CronJobSpec;
    constructor(metadata: ObjectMeta, spec: CronJobSpec);
    get yaml(): string;
}
export declare class PodDisruptionBudget {
    metadata: ObjectMeta;
    spec: PodDisruptionBudgetSpec;
    constructor(metadata: ObjectMeta, spec: PodDisruptionBudgetSpec);
    get yaml(): string;
}
export declare class Job {
    metadata: ObjectMeta;
    spec: Omit<JobSpec, "selector">;
    constructor(metadata: ObjectMeta, spec: Omit<JobSpec, "selector">);
    get yaml(): string;
}
export declare class PersistentVolumeClaim {
    metadata: ObjectMeta;
    spec: PersistentVolumeClaimSpec;
    constructor(metadata: ObjectMeta, spec: PersistentVolumeClaimSpec);
    get yaml(): string;
}
export {};
