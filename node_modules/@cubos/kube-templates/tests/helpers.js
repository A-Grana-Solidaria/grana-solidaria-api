"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.portForward = exports.sleep = exports.waitJobComplete = exports.waitPodReady = exports.randomSuffix = exports.apply = exports.deleteObject = exports.kubectl = void 0;
var child_process_1 = require("child_process");
var deasync_1 = __importDefault(require("deasync"));
var fs_1 = require("fs");
function rawKubectl() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = child_process_1.spawnSync("kubectl", __spreadArrays(["--kubeconfig=.test-kubeconfig"], args));
    if (result.status === 0) {
        return result.stdout.toString();
    }
    else {
        throw new Error(result.stderr.toString());
    }
}
function kubectl() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return JSON.parse(rawKubectl.apply(void 0, __spreadArrays(["--output=json"], args)));
}
exports.kubectl = kubectl;
function deleteObject(kind, name) {
    rawKubectl("delete", kind, name);
}
exports.deleteObject = deleteObject;
function apply(_a) {
    var yaml = _a.yaml;
    var path = "/tmp/kube." + randomSuffix() + ".yaml";
    fs_1.writeFileSync(path, yaml);
    try {
        return kubectl("apply", "-f", path);
    }
    finally {
        fs_1.unlinkSync(path);
        sleep(2);
    }
}
exports.apply = apply;
function randomSuffix() {
    return new Date().getTime() + "-" + Math.floor(Math.random() * 100000);
}
exports.randomSuffix = randomSuffix;
function waitPodReady(namespace, pod, timeout) {
    if (timeout === void 0) { timeout = 60; }
    var start = new Date().getTime();
    while (true) {
        var podInfo = kubectl("-n", namespace, "get", "pod", pod);
        if (!podInfo) {
            throw new Error("pod " + pod + " does not exist");
        }
        if (podInfo.status.containerStatuses &&
            podInfo.status.containerStatuses.every(function (x) { return x.ready; })) {
            return;
        }
        if (new Date().getTime() - start > timeout * 1000) {
            throw new Error("timeout while waiting for pod " + pod + " to become ready");
        }
        sleep(1);
    }
}
exports.waitPodReady = waitPodReady;
function waitJobComplete(namespace, job, timeout) {
    if (timeout === void 0) { timeout = 60; }
    var start = new Date().getTime();
    while (true) {
        var jobInfo = kubectl("-n", namespace, "get", "job", job);
        if (!jobInfo) {
            throw new Error("Job " + job + " does not exist");
        }
        if (jobInfo.status.succeeded === 1) {
            return;
        }
        if (new Date().getTime() - start > timeout * 1000) {
            throw new Error("timeout while waiting for Job " + job + " to become ready");
        }
        sleep(1);
    }
}
exports.waitJobComplete = waitJobComplete;
function sleep(seconds) {
    deasync_1.default.sleep(seconds * 1000);
}
exports.sleep = sleep;
function portForward(namespace, pod, containerPort) {
    var port = 63317 + parseInt(process.env.JEST_WORKER_ID, 10);
    var proc = child_process_1.spawn("kubectl", [
        "--kubeconfig=.test-kubeconfig",
        "-n",
        namespace,
        "port-forward",
        pod,
        port + ":" + containerPort,
    ]);
    var stdout = "";
    var stderr = "";
    var exitCode = null;
    proc.stdout.on("data", function (data) {
        stdout += data;
    });
    proc.stderr.on("data", function (data) {
        stderr += data;
    });
    proc.addListener("exit", function (code) {
        exitCode = code;
    });
    for (var i = 0; i < 30; ++i) {
        if (stdout.includes("Forwarding from 127.0.0.1:" + port + " -> " + containerPort))
            break;
        sleep(0.1);
        if (exitCode !== null) {
            throw new Error(stderr);
        }
    }
    return {
        port: port,
        close: function () {
            proc.kill("SIGINT");
        },
    };
}
exports.portForward = portForward;
